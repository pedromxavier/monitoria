\documentclass[12pt]{article}

\usepackage{comptype}

\title{%%
Lista de Computação I (Python) \\
{\normalsize DCC / UFRJ}
}

\author{%%
Pedro Maciel Xavier (monitor)\\ 
\texttt{pedromxavier@poli.ufrj.br}
}

\begin{document}
	\maketitle
	\section*{Introdução}
	%--- ''Fala galerinha do YouTube!'' --- EXTREME, Venom.
	%~\\
	%~\\
	Essa lista de exercícios ainda se encontra em desenvolvimento. A intenção é que ela tenha um gabarito bem aberto, deixando muito das respostas para a criatividade do aluno. As questões estão organizadas em relação aos assuntos. Mesmo assim cada exercício demanda conhecimentos da disciplina como um todo. Elas tem estrelinhas $\star$ indicando a dificuldade estimada. É importante você tire suas dúvidas e dê um retorno do que achou dos exercícios através do \texttt{e-mail} no cabeçalho.
	~\\
	~\\
	Boa diversão! \par
	
	\cc
	
	\tableofcontents
	
	\chap{Funções e Recursividade (\stmt{def}, \stmt{return})}
	
	\begin{interlude}{\texttt{*args} e \texttt{**kwargs}}
	
	Oberseve esta forma de definir uma função:
	\begin{lstlisting}
def f(x, *y, **z):
	print(x)
	print(y)
	print(z)
...
>>> f(0, 1, 2, 3, penúltimo=4, último=5)
0
(1, 2, 3)
{'penúltimo' : 4, 'último' : 5}
	\end{lstlisting}
	
	Pode parecer um tanto confuso de início, mas o que estamos falando aqui é de parâmetros opcionais (\texttt{*args}) e de 
	
	\end{interlude}
	
	\begin{interlude}{Funções são objetos}
	
	No \texttt{Python} quase tudo é objeto. O conceito de objeto vai ficar mais claro no curso de \href{https://github.com/pedromxavier/monitoria/blob/master/tex/comp2.pdf}{Computação II}. O importante agora é saber que uma função não é tão diferente dos outros tipos, como os inteiros (\type{int}), listas (\type{list}) e strings (\type{str}). Isso tem uma implicação imediata: podemos passar funções como parâmetros pra outras funções. Isso pode ser muito útil, como veremos mais adiante, para calcular
	
	\end{interlude}	
	
	\problem[1]{Fibonacci \textit{X-treme}}
	
	A sequência de Fibonacci é definida por
	\begin{align*}
		\begin{cases}
		F_{n} = F_{n-1} + F_{n-2}\\
		F_{0} = 0 \text{ e } F_{1} = 1
		\end{cases}
	\end{align*}
	
	O $n$-ésimo termo pode ser obtido pela função

	\begin{lstlisting}[caption="Fibonacci"]
def f(n):
	if n == 0:
		return 0
	elif n == 1:
		return 1
	else:
		return f(n-1) + f(n-2)
	\end{lstlisting}
	
	\quest Tente encontrar, usando a função acima, o número $F_{50}$.
	
	\begin{interlude}{Decoradores}
	
	Decoradores são funções que proporcionam uma maneira simples de alterar o funcionamento de uma função no momento da sua definição. Um decorador recebe uma função como parâmetro e dever retornar também uma função.
	
	\begin{lstlisting}
def mod3(f):
	def g(x):
		return f(x) % 3
	return g
	
@mod3
def f(x):
	return x ** 2 + 1
	\end{lstlisting}	
	
	\end{interlude}
	
	\problem[3]{Tempo}
	
	Agora que já sabemos como construir uma função e decorá-la, podemos fazer um decorador que nos ajude a medir o tempo que uma função leva pra rodar.
	
	\problem[1]{Diferencial I}
	
	Aprendemos em Cálculo I que a derivada de uma função $f(x)$ pode ser calculada como:
	
		$$f'(x) = \lim_{h \to 0} \frac{f(x + h) - f(x)}{h}$$
	
	Se escolhemos um $h$ pequeno, algo como $0.001$, podemos deixar a ideia de limite de lado e partir para uma aproximação
	
		$$f'(x) \approx \frac{f(x + h) - f(x)}{h} \text{ para } h \ll 1$$

	Outras aproximações razoáveis são	
		\begin{align*}
		f'(x) &\approx \frac{f(x + h) - f(x - h)}{2h}\\
		\\		
		f'(x) &\approx \frac{\im{f(x + \mb{i}h)}}{h} 
		\end{align*}	
	sendo essa última um pouco mais holística.\\
	
	\textbf{Desafio:} Faça uma função \texttt{d(f, h)} que receba uma função \texttt{f} e um número bem pequeno \texttt{h} e retorne uma outra função, que aproxime a derivada de \texttt{f}.
	
	\chap{Condições (\stmt{if}, \stmt{elif}, \stmt{else})}
	
	\problem[1]{Funções por partes}
	
	Funções podem ser definidas por partes, isto é, utilizamos uma função para cada trecho do domínio. Dentre os exemplos mais conhecidos temos

\begin{itemize}

	\item[] A função de \textit{Heaviside}, ou função degrau:
	\begin{align*}
		u(t) \triangleq	\begin{cases}
		1, \text{ se } t \geq 0\\
		0, \text{ c.c.}
		\end{cases}
	\end{align*}
	
	\item[] A sua derivada, o delta de Dirac \footnote{Uma definição mais precisa supõe que $\displaystyle \int_{\mathbb{R}} \delta(t)\ dt = 1$}:
	\begin{align*}
		\delta(t) \triangleq	\begin{cases}
		\infty, \text{ se } t = 0\\
		\phantom{0}0, \text{ c.c.}
		\end{cases}
	\end{align*}
	
	\item[] O módulo de um número real:
	\begin{align*}
		|x| \triangleq	\begin{cases}
		\phantom{-}x, \text{ se } x \geq 0\\
		-x, \text{ c.c.}
		\end{cases}
	\end{align*}	
\end{itemize}
	
	Mas podemos pensar muitos outros exemplos a tirar da cartola

\begin{itemize}

	\item[]	\begin{align*}
		f(x) \triangleq	\begin{cases}
		1, \text{ se } t \geq 0\\
		0, \text{ c.c.}
		\end{cases}
	\end{align*}		
\end{itemize}

	\quest Utilize condicionais para criar funções definidas por partes, como as dos exemplos.
	
	\chap{Laços (\stmt{for}, \stmt{while})}
	
	\problem[2]{Sequência de Collatz}
	
	A sequência de Collatz é descrita recursivamente por:
	{\large
	\begin{align*}
		f(n) \triangleq \begin{cases}
		3n + 1, &\text{ se } n \text{ for ímpar}\\
		n \div 2, &\text{ se } n \text{ for par}
		\end{cases}
	\end{align*}
	}
	Por exemplo, começamos com $n = 26$. Após sucessivas aplicações temos:
		$$26 \to 13 \to 40 \to 20 \to 10 \to 5 \to 16 \to 8 \to 4 \to 2 \to 1$$
	Isso nos dá uma sequência com $11$ números. $40$ é maior que $26$, mas sua sequência só teria $9$ números.\\
	\\
	Ainda não se sabe se todos os números induzem uma sequência que termina em $1$. No entanto, até agora não foi encontrado um número sequer em que isso não tenha acontecido!\\
	\\
	\textbf{Deasfio: } Faça uma função que calcule o comprimento da sequência gerada a partir de um número natural $n$ qualquer.
	
	\problem[3]{Integral I}
	
	A \textbf{Integral de Riemann} é dada por:
	
		$$\int_{a}^{b} f(x)\ dx = \lim_{N \to \infty} \sum_{k = 0}^{N} f(x_k) \cdot \delta x \text{ onde } \delta x = \frac{(b - a)}{N} \text{ e } x_k = a + k \cdot \delta x$$
	
	No entanto, vamos nos ater somente a um $N$ suficientemente grande e deixar o limite para lá.\\
	
	\quest Faça uma função que calcule o valor da integral definida de uma função \texttt{f}, dados os limites \texttt{a} e \texttt{b}, assim como o valor de \texttt{N}.
	
	
	\chap{Números (\type{int}, \type{float}, \type{complex})}

	\problem[2]{Números Primos}
	
	\textbf{Desafio:} Faça uma função que verifique se um número é primo ou não.

	\problem[1]{Gerando números "aleatórios"}
	
	Gerar um numero aleatório é um pouco complicado em geral. Muitas formas de se fazer isso hoje em dia se baseiam em processos da natureza como fluidos em regime turbulento ou fenômenos quânticos. No entanto, é possível chegar perto disso com muito menos. Para começar, escolhemos uma potência de $2$, como $\mathbf{N} = 2^{16} = 65536$. Depois disso, escolhemos um número primo no meio do caminho, digamos, $\mathbf{p} = 25773$. Por fim, um númeror ímpar menor que o número primo $\mathbf{p}$, por exemplo, $\mathbf{b} = 13849$.\\

	Partimos de um número $\mathbf{n}_0$ qualquer no intervalo $[0, 25536)$ e calculamos o sucessor da seguinte forma:
		\begin{align*}
			\mathbf{n}_j = \mathbf{p} \times \mathbf{n}_{j-1} + \mathbf{b} \mod \mathbf{N}
		\end{align*}

	Para obter um número "aleatório"~ distribuído de maneira uniforme no intervalo $[0, 1)$, basta calcular
		$$\mathbf{x}_j = \frac{\mathbf{n}_j}{\mathbf{N}}$$
		
	\textbf{Desafio:} Faça o seu próprio gerador de números aleatórios!
		
	\problem[1]{Música I}\label{p:musica1}
	
	Uma \textbf{nota musical} é o nome que se dá ao som relativo a uma frequência específica. Uma \textbf{oitava} é o intervalo entre uma nota musical e aquela que possui o dobro da sua frequência. Na música ocidental, uma \textbf{oitava} é dividida em 12 tons.\\
	
	A nota \textit{lá}, cujo símbolo é A, é normalmente dada pela frequência de 440Hz. Isso significa que também chamaremos de \textit{lá} os sons de 220Hz, 880Hz e assim por diante.\\
	
	
	\begin{center}
	\scriptsize
	\begin{TAB}(c,1cm,1cm)[5pt]{|c|c|c|c|c|c|c|c|c|c|c|c|}{|c|c|}
		A & A\# & B & C & C\# & D & D\# & E & F & F\# & G & G\#\\
		0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11\\
	\end{TAB}
	\end{center}
	
	\textbf{Desafio:} Faça uma função que calcule a frequência $\mathbf{f}$ de cada nota, a partir do seu número, supondo que $\mathbf{f}(0) = 440\text{Hz}$.
	
	
	
	
	
	\chap{\textit{Strings} e Texto (\type{str})}

	\problem[2]{DNA I}
	
	Uma sequência de DNA (\emph{ácido desoxirribonucleico}) é composta por 4 nucleotídeos: \textbf{A}denina, \textbf{C}itosina, \textbf{G}uanina \textbf{T}imina. Já no RNA mensageiro (mRNA), a \textbf{T}imina está ausente, e dá lugar para a \textbf{U}racila. Quando um ribossomo realiza a transcrição de DNA em mRNA ele segue uma regra muito simples:
		
	\begin{center}
			\begin{tabular}{ccc}
				A & $\rightarrow$ & U\\
				T & $\rightarrow$ & A\\
				C & $\rightarrow$ & G\\
				G & $\rightarrow$ & C\\
			\end{tabular}
	\end{center}
	
	Além disso, o DNA possui alguns códons (sequências de 3 nucleotídeos) que indicam o início e fim de uma transcrição. ATG marca o início, enquanto TAG, TAA, e TGA indicam o final.\\
	
	Podemos representar uma fita de DNA usando uma \emph{string} (\type{str}), como por exemplo:
	\begin{center}
	\str{ACAATGTGTACGACTATACTACGTGCCTATTCGCATACGATCGATGACTAG}	
	\end{center}
	
	\textbf{Desafio:} Faça uma função que traduza uma fita de DNA como faria um ribossomo. Ela deve receber uma \textit{string} de DNA e retornar uma \textit{string} de mRNA. Por exemplo, a fita de DNA acima seria transcrita em
	\begin{center}
	\str{ACAUGCUGAUAUGAUGCACGGAUAAGCGUAUGCUAGCUACUG}	
	\end{center}
	
	
	\problem[4]{Separando sílabas}
	
	Separa sílabas é uma tarefa interessante. O Português é uma das poucas línguas que possui um algoritmo que permite saber como separar as sílabas de uma palavra qualquer, isto é, se uma palavra nova for criada hoje em português, já é possível dividí-la mesmo sem conhecer a sua origem.
	
	\begin{center}
		Flamengo $\to$ Fla-men-go
	\end{center}
	
	Um algoritmo de separação silábica, para uma língua qualquer, normalmente conta com duas coisas: Um conjunto de regras e um conjunto de exceções.\\
	
	As regras nada mais são do que padrões que, uma vez observados, implicam em uma cisão na palavra. Por exemplo, consoantes dobradas como \textbf{rr} e \textbf{ss} sempre vão indicar uma separação:
	
	\begin{center}
		Pá\textbf{ss}aro $\to$ Pá\textbf{s}-\textbf{s}a-ro\\
		Ca\textbf{rr}o\textbf{ss}el $\to$ Ca\textbf{r}-\textbf{r}o\textbf{s}-\textbf{s}el
	\end{center}
	
	As exceções nada mais são do que um conjunto de palavras que já sabemos como separar, armazenadas em pares da forma (palavra, separação).\\
	
	\textbf{Desafio:} Crie um conjunto de regras para que, dada uma palavra (\type{str}), a função retorne uma lista com a respectiva separação silábica. Exemplo:
	
	\begin{lstlisting}[caption="Separando sílabas"]
>>> f('pássaro')
['pás', 'sa', 'ro']
>>> f('carrossel')
['car', 'ros', 'sel']
>>> f('paralelepípedo')
['pa', 'ra', 'le', 'le', 'pí', 'pe', 'do']
	\end{lstlisting}
	
	\problem[3]{Bases numéricas alternativas}
	
	\subsubsection*{Binária}
	
	\subsubsection*{Hexadecimal}
	
	\begin{tabular}{rrrrrrrrrrrrrrrr}
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & A & B & C & D & E & F\\
10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 1A & 1B & 1C & 1D & 1E & 1F\\
20 & 21 & 22 & 23 & 24 & 25 & 26 & 27 & 28 & 29 & 2A & 2B & 2C & 2D & 2E & 2F\\
30 & 31 & 32 & 33 & 34 & 35 & 36 & 37 & 38 & 39 & 3A & 3B & 3C & 3D & 3E & 3F\\
40 & 41 & 42 & 43 & 44 & 45 & 46 & 47 & 48 & 49 & 4A & 4B & 4C & 4D & 4E & 4F\\
50 & 51 & 52 & 53 & 54 & 55 & 56 & 57 & 58 & 59 & 5A & 5B & 5C & 5D & 5E & 5F\\
60 & 61 & 62 & 63 & 64 & 65 & 66 & 67 & 68 & 69 & 6A & 6B & 6C & 6D & 6E & 6F\\
70 & 71 & 72 & 73 & 74 & 75 & 76 & 77 & 78 & 79 & 7A & 7B & 7C & 7D & 7E & 7F\\
80 & 81 & 82 & 83 & 84 & 85 & 86 & 87 & 88 & 89 & 8A & 8B & 8C & 8D & 8E & 8F\\
90 & 91 & 92 & 93 & 94 & 95 & 96 & 97 & 98 & 99 & 9A & 9B & 9C & 9D & 9E & 9F\\
A0 & A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9 & AA & AB & AC & AD & AE & AF\\
B0 & B1 & B2 & B3 & B4 & B5 & B6 & B7 & B8 & B9 & BA & BB & BC & BD & BE & BF\\
C0 & C1 & C2 & C3 & C4 & C5 & C6 & C7 & C8 & C9 & CA & CB & CC & CD & CE & CF\\
D0 & D1 & D2 & D3 & D4 & D5 & D6 & D7 & D8 & D9 & DA & DB & DC & DD & DE & DF\\
E0 & E1 & E2 & E3 & E4 & E5 & E6 & E7 & E8 & E9 & EA & EB & EC & ED & EE & EF\\
F0 & F1 & F2 & F3 & F4 & F5 & F6 & F7 & F8 & F9 & FA & FB & FC & FD & FE & FF
	\end{tabular}		
	
	\subsubsection*{Babilônia}
	
	Estamos habituados com a base decimal, muito provavelmente porquê temos 10 dedos. O pessoal da antiga Babilônia tinha um sistema sexagesiaml: Isso mesmo, eram 60 dígitos diferentes!
	
	\figura[width=\textwidth]{babylonian_numerals.png}{Dígitos Babilônicos 2000 a.C.}
	
	Na verdade, eram só 59 porquê eles ainda não tinham o zero e deixavam um espaço em branco no lugar dele o que na hora das contas devia ser uma Torre de Babel! Dá pra perceber que apesar disso, a composição dos símbolos ainda tem sua própria carga da notação decimal, mesclando-a com a base 6.\\
	
	\textbf{Desafio:} Crie uma função que transforme um número na base decimal em uma representação (\type{str}) na base babilônica, assim como uma outra que faça o caminho contrário.	
		
	
	\chap{Listas e Tuplas (\type{list}, \type{tuple})}
	
	\problem[2]{Crivo}
	
	O Eratóstenes foi um cara legal que viveu em 200 a.C., bolou um crivo e calculou a curvatura da terra.
	
	\figura[width=168pt]{eratostenes.png}{Eratóstenes de Cirene}
	
	Um \textbf{crivo} é uma forma de saber quem são os números primos até um determinado limite $\mb{N}$. O Crivo de Eratóstenes funciona de forma bem simples:
	
	\begin{enumerate}
		\item Escrevemos em uma tabela todos os números de 0 até $\mb{N}$.
		\item Riscamos o 0 e o 1.
		
		\item Se um número não estiver riscado, riscamos todos os múltiplos deste, menos o próprio.
		
		\item Andamos para o próximo número e repetimos a etapa anterior.		
	\end{enumerate}
	
	Uma maneira interessante de fazer isso é criando uma lista de tamanho $\mb{N} + 1$, ou seja, cujos índices vão de 0 até $\mb{N}$.
	
	
	\chap{Conjuntos e Dicionários (\type{set}, \type{dict})}
	
	\problem[2]{Música II}\label{p:musica2}
	
	Usando a função do exercício \textbf{Música I}[\ref{p:musica1}], podemos usar um dicionário para obter a frequência a partir do símbolo que representa a nota.
	
	\chap{Arquivos (\stmt{with}, \type{open})}
	
	\begin{interlude}{\texttt{csv}}
	
	Arquivos no formato \texttt{.csv} (\textit{comma separated values}) são muito utilizados para representar tabelas em um arquivo de texto. São facilmente lidos por programas como o Excel$^{\tiny \text{TM}}$.\\
	
	Por exemplo, o arquivo
	
	\begin{lstlisting}
nome,CPF,idade
João,82252631704,11
Pedro,12432236702,21
Anna,13241232392,15
	\end{lstlisting}
	
	é interpretado como
	
	\begin{center}
	\begin{tabular}{|c|c|c|}
	\hline
	nome  & CPF         & idade\\
	\hline 
	João  & 82252631704 &11\\
	\hline
	Pedro & 12432236702 &21\\
	\hline
	Anna  & 13241232392 &15\\
	\hline
	\end{tabular}
	\end{center}
	
	\end{interlude}
	
\end{document}